{"version":3,"file":"index.umd.js","sources":["../src/index.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react'\r\nimport './scroll-animate.css'\r\nfunction ScrollAnimate({ children, animation, className, delay = 1, duration = 1, infinite = false }) {\r\n\r\n    const targetElement = useRef(null);\r\n    let valueX;\r\n    let valueY;\r\n    let Valuedeg;\r\n    const offset = [\r\n        {\r\n            'offsetType': 'up',\r\n            'operate': '--animation-offsetup',\r\n            'valueIndex': 0,\r\n            'valueDirection': ''\r\n        },\r\n        {\r\n            'offsetType': 'down',\r\n            'operate': '--animation-offsetdown',\r\n            'valueIndex': 0,\r\n            'valueDirection': '-'\r\n        },\r\n\r\n        {\r\n            'offsetType': 'left',\r\n            'operate': '--animation-offsetleft',\r\n            'valueIndex': 1,\r\n            'valueDirection': '-'\r\n        },\r\n        {\r\n            'offsetType': 'right',\r\n            'operate': '--animation-offsetright',\r\n            'valueIndex': 1,\r\n            'valueDirection': ''\r\n        },\r\n        {\r\n            'offsetType': 'top',\r\n            'operate': '--animation-offsettop',\r\n            'valueIndex': 0,\r\n            'valueDirection': '-'\r\n        },\r\n        {\r\n            'offsetType': 'bottom',\r\n            'operate': '--animation-offsetbottom',\r\n            'valueIndex': 0,\r\n            'valueDirection': ''\r\n        },\r\n\r\n\r\n    ]\r\n\r\n    const offsetHandler = (animate, ele, offsetValue) => {\r\n\r\n        const animateString = animate\r\n        const value = offsetValue.split(',');\r\n\r\n        // ValueDeg = value[2];\r\n\r\n        offset.map(a => {\r\n\r\n            if (animateString.includes(a.offsetType)) {\r\n\r\n\r\n\r\n                //  ele.style.setProperty(a.operate, a.valueDirection + value[a.valueIndex] + '%');\r\n\r\n            }\r\n        }\r\n\r\n        )\r\n\r\n    }\r\n\r\n    useEffect(() => {\r\n        const option = {\r\n            rootMargin: '0px',\r\n            threshold: [0.3],\r\n            once: true\r\n\r\n        };\r\n\r\n        const observer = new IntersectionObserver((entries) => {\r\n            entries.forEach((a, index) => {\r\n\r\n                if (delay > 1) {\r\n\r\n                    if (targetElement.current.style.opacity !== \"1\") {\r\n                        targetElement.current.style.opacity = 0;\r\n                    }\r\n\r\n                }\r\n\r\n                if (a.isIntersecting) {\r\n\r\n                    //  const animate = a.target.getAttribute('scroll-animate');\r\n                    // const duration = a.target.getAttribute('scroll-animate-duration');\r\n                    // const offset = a.target.getAttribute('scroll-animate-offset')\r\n                    // const defaultDuration = '1';\r\n\r\n                    setTimeout(() => {\r\n                        if (targetElement.current.style.opacity === \"0\") {\r\n                            targetElement.current.style.opacity = 1;\r\n                        }\r\n\r\n\r\n                        a.target.classList.add(animation)\r\n\r\n\r\n                    }, delay)\r\n\r\n                    if (duration) {\r\n                        targetElement.current.style.setProperty('--animation-duration', duration + 's');\r\n                    }\r\n\r\n                    if (infinite) {\r\n\r\n                        a.target.addEventListener('animationend', () => {\r\n                            a.target.classList.remove(animation);\r\n\r\n                        });\r\n                    }\r\n\r\n\r\n                }\r\n            })\r\n\r\n        }, option);\r\n\r\n\r\n        observer.observe(targetElement.current);\r\n\r\n\r\n\r\n    }, [])\r\n    return (\r\n        <div ref={targetElement} className={`${className}`}>\r\n            {\r\n                children\r\n            }\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default ScrollAnimate"],"names":["_ref","children","animation","className","_ref$delay","delay","_ref$duration","duration","_ref$infinite","infinite","targetElement","useRef","useEffect","IntersectionObserver","entries","forEach","a","index","current","style","opacity","isIntersecting","setTimeout","target","classList","add","setProperty","addEventListener","remove","rootMargin","threshold","once","observe","_jsx","jsx","ref"],"mappings":"gVAEA,SAAsBA,GAAG,IAAAC,EAAQD,EAARC,SAAUC,EAASF,EAATE,UAAWC,EAASH,EAATG,UAASC,EAAAJ,EAAEK,MAAAA,OAAK,IAAAD,EAAG,EAACA,EAAAE,EAAAN,EAAEO,SAAAA,OAAW,IAAHD,EAAG,EAACA,EAAAE,EAAAR,EAAES,SAAAA,OAAQ,IAAAD,GAAQA,EAExFE,EAAgBC,EAAMA,OAAC,MAiI7B,OA7DAC,EAAAA,UAAU,WAQW,IAAIC,qBAAqB,SAACC,GACvCA,EAAQC,QAAQ,SAACC,EAAGC,GAEZZ,EAAQ,GAEoC,MAAxCK,EAAcQ,QAAQC,MAAMC,UAC5BV,EAAcQ,QAAQC,MAAMC,QAAU,GAK1CJ,EAAEK,iBAOFC,WAAW,WACqC,MAAxCZ,EAAcQ,QAAQC,MAAMC,UAC5BV,EAAcQ,QAAQC,MAAMC,QAAU,GAI1CJ,EAAEO,OAAOC,UAAUC,IAAIvB,EAG3B,EAAGG,GAECE,GACAG,EAAcQ,QAAQC,MAAMO,YAAY,uBAAwBnB,EAAW,KAG3EE,GAEAO,EAAEO,OAAOI,iBAAiB,eAAgB,WACtCX,EAAEO,OAAOC,UAAUI,OAAO1B,EAE9B,GAKZ,EAEJ,EApDe,CACX2B,WAAY,MACZC,UAAW,CAAC,IACZC,MAAM,IAoDDC,QAAQtB,EAAcQ,QAInC,EAAG,iBAECe,EAAAC,IAAA,MAAA,CAAKC,IAAKzB,EAAeP,UAAS,GAAKA,EAAYF,SAE3CA,GAIhB"}